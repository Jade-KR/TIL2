# 부트 매니저

> 부트 매니저는 보조 기억장치에 위치한 운영체제를 주기억장치로 로드하기 위한 프로그램이며 부트 로더라고도 한다

시스템이 켜지면 커널이 메모리에 올라와 실행되어야 하는데 커널이 바로 실행이 되는게 아니라 중간에 부트매니저가

먼저 실행이되고 부트 매니저가 커널을 로드해준다. 



### 동작 원리

시스템이 켜지면 BIOS는 디스크의 첫 번째 섹터(0번 섹터)인 부트 섹터에서 512바이트의 MBR(Master Boot Record)를 읽는다. MBR은 크기가 제한되기 때문에 IPL(Initial Program Loader) 이라 불리는 부트 로더의 일부가 먼저 실행된다.

IPL은 파티션 테이블을 검사하여 부트 로더의 나머지 코드의 위치를 알아내 실행한다.



리눅스의 대표적인 부트 매니저 프로그램은 LILO(Linux Loader)와 GRUB(Grand Unified BootLoader)가 있다.



### LILO(Linux Loader)

> 모든 리눅스 배포판의 표준이자 가장 오래된 부트 로더

- LILO 설정은 /etc/lilo.conf 설정 파일에서 이루어진다.
- 설정 파일을 변경 후 LILO stage 1 부트로더를 MBR로 다시 쓰기 위해 lilo 명령을 반드시 수행해야한다.



### GRUB(Grand Unified Boot Loader)

- GNU 프로젝트에서 만든 부트 로더이다.
- LILO와 달리 대화형 명령어 인터페이스를 제공하고 네트워크 부팅을 제공한다.
- 배포판 마다 설정 파일 명이 다를 수 있는데 CentOS 6의 경우 /boot/grub/grub.conf 파일이 존재한다.
- LILO와 달리 설정 파일 변경 후 특별한 조치가 필요 없다.

![스크린샷 2020-11-11 오후 10.16.27](/Users/kimjeongdeok/TIL2/note/img/스크린샷 2020-11-11 오후 10.16.27.png)

이미지

![스크린샷 2020-11-11 오후 10.18.42](/Users/kimjeongdeok/TIL2/note/img/스크린샷 2020-11-11 오후 10.18.42.png)

### 디렉터리 구조

![스크린샷 2020-11-11 오후 10.21.43](/Users/kimjeongdeok/TIL2/note/img/스크린샷 2020-11-11 오후 10.21.43.png)![스크린샷 2020-11-11 오후 10.18.52](/Users/kimjeongdeok/TIL2/note/img/스크린샷 2020-11-11 오후 10.18.52.png)

![스크린샷 2020-11-11 오후 10.18.42](/Users/kimjeongdeok/TIL2/note/img/스크린샷 2020-11-11 오후 10.18.42.png)

### 부팅과 셧다운

####부팅

> 컴퓨터의 전원이 켜진 후 사용자가 시스템을 사용할 수 있도록 운영체제를 기동하는 절차 혹은 과정

- 부팅을 하기위해서 BIOS는 MBR로부터 부트 로더를 실행한다.
- 부트 로더는 사용자가 지정한 운영체제가 들어있는 디스크로 찾아가서 메모리에 올린다.
- 운영체제에게 제어권을 운영체제가 실행하게 하는 과정을 수행함



#### 부팅 과정

![스크린샷 2020-11-11 오후 10.24.58](/Users/kimjeongdeok/TIL2/note/img/스크린샷 2020-11-11 오후 10.24.58.png)

1. 시스템 시작 및 하드웨어 초기화

   - ROM 영역에 저장된 프로그램으로 시스템을 켜면 가장 먼저 실행된다.
   - 컴퓨터 하드웨어 인식과 각 장치들의 사용을 위한 준비를 수행

2. 부트 로더 1단계

   - 하드디스크 0번 섹터를 특별히 MBR 이라고 부르며 운영체제 로드를 위한 부트 로더가 위치한다.
   - 0번 섹터는 512바이트로 크기가 한정적이라서 실제 부트 로더가 위치한 디스크로 점프하는 역할까지 수행.

3. 부트 로더 2단계

   - 실제 부트 로더가 실행. 리눅스의 경우 LILO 혹은 GRUB
   - GRUB는 MBR 이후로 약 30kilobytes 내에 연속된 주소에 위치.
   - GRUB는 grub.conf의 설정에 따라 선택할 수 있는 운영체제 목록을 표시.
   - 사용자가 운영체제를 선택하면 해당 운영체제를 위한 커널을 메모리에 로드하고 해당 커널에 제어권을전달.

4. 커널

   - 커널은 하드웨어와 소프트웨어를 관장하는 핵심 모듈
   - 커널은 한 번 메모리(RAM)에 로드되면 시스템이 리부팅하거나 종료할 때까지 상주한다.
   - GRUB로 부터 제어권을 이어받은 커널은 INIT 프로세스를 실행한다.

5. INIT 프로세스

   - INIT 프로세스는 부팅을 위해 필요한 초기화 작업을 실제로 수행한다.
   - INIT 프로세스는 가장 먼저 모든 시스템의 프로퍼티, 하드웨어, 디스플레이, SELinux, 커널 모듈, 파일시스템 마운트 등을 체크하기 위해 /etc/rc.d/rc./sysinit 스크립트를 수행한다.
   - INIT 프로세스는 /ect/inittab 파일을 읽어 실행레벨을 확인하고 그에 맞는 스크립트를 실행한다. 가령 실행레벨이 5인 경우 /etc/rc5.d 디렉터리에 위치한 스크립트가 실행된다.
   - 실행레벨과 관련된 스크립트 모두 수행하고 나면 INIT 프로세스는 /etc/rc.local에 정의된 프로세스를 마지막으로 실행한다.

   ![스크린샷 2020-11-11 오후 10.36.09](/Users/kimjeongdeok/TIL2/note/img/스크린샷 2020-11-11 오후 10.36.09.png)

6. 사용자 프롬프트(user prompt)

   - 모든 초기화가 완료되면 실행레벨에 따라 다르지만 X-Window가 표시되거나 terminal을 통해 사용자의 입력을 받을 준비가 완료된다.





### 시스템 종료 (Shutdown)

- system 메뉴에서 Shutdown 을 눌러 시스템을 종료하거나 재시작 할 수 있다.

- shutdown -h now
- halt
- poweroff
- init 0



시스템을 재부팅 하는 방법

- shutdown -r now
- reboot
- init 6



예약된 시간에 시스템을 종료하거나 재시작 하는 방법

- 5분뒤 종료 : shutdown -h +5
- 특정시간 종료 : shutdown -h 10 : 00
- 5분 뒤 재부팅 : shutdown -r +5





### 파일 시스템

> 디스크에 사용자의 데이터를 효율적으로 저장하기 위한 파일과 디렉터리를 조직화한 체계

- 포맷 - 디스크를 일정한 크기로 분할하고 주소를 설정하여 사용자의 자료를 조직적으로 보관할 수 있게 한다.
- 사용자 데이터는 파일 단위로 관리가 되며 디스크에 저장할 때에는 레코드 단위 혹은 블록단위로 저장이 된다. 각 파일은 디렉터리에 속하여 그룹을 생성할 수 있기 때문에 많은 파일을 체계적으로 관리할 수 있다.
- 파일 시스템은 파일 입출력 시 발생하는 오류에 대하여 복구할 수 있는 기능도 제공한다.
- 파일시스템은 캐시 기능을 제공하여 디스크의 입출력을 최소화한다.



### 리눅스 파일시스템의 구조

ext2를 근간으로 발전하였기 때문에 ext2의 파일시스템을 이해하면 된다.



#### 부트 섹터와 블록 그룹

- ext2 파일시스템은 부트 섹터와 그에 뒤따르는 여러 개의 블록 그룹들로 구성된다.
- 블록 그룹은 모두 같은 블록 개수를 가진다. 단, 마지막 블록 그룹은 예외다.



#### 블록 그룹![스크린샷 2020-11-11 오후 10.54.10](/Users/kimjeongdeok/TIL2/note/img/스크린샷 2020-11-11 오후 10.54.10.png)

#### 슈퍼 블록

- 파일 시스템의 전체 내용을 담고 있는 블록 1KB만 사용한다.
- 블록의 크기, 총 블록의 개수, 블록 그룹의 개수, 아이노드의 개수, 그룹 내 블록의 개수, 그룹 내 아이노드의 개수 등에 대한 정보가 포함되어 있다



#### 그룹 디스크립터 테이블

- 블록 그룹에 대한 정보를 담고 있음
- 블록 비트맵의 블로번호, 아이노드 비트맵의 블록번호, 첫 번째 노드 테이블의 블록 번호, 그룹 안에 있는 빈 블록의 수, 그룹 안에 있는 아이노드 수, 그룹안에 있는 빈 디렉터리 수의 정보가 포함되어 있다



#### 블록 비트맵

- 각 비트에 해당하는 블록이 사용 중이면 1, 사용 중이지 않으면 0으로 나타낸다.



#### 아이노드 비트맵

- 아이노드의 할당 여부를 비트로 나타낸다

#### 아이노드 테이블

- 연속된 블록으로 이루어져 있으며 각 블록은 정의된 아이노드 개수를 포함한다.
- 아이노드의 첫 번째 블록의 번호를 그룹 디스크립터 테이블에 저장한다.
- 모든 아이노드의 크기는 128바이트로 동일하다.

#### 아이노드

- 실제 파일과 디렉터리의 데이터 위치를 알고있는 자료구조이다.

- 아이노드는 Inode Number, 파일모드, 하드링크 수, 소유자 ID, 파일 크기, 마지막 접근, 마지막 수정, Inode 수정, 데이터 블록 수의 정보를 가지고 있다.

- 모든 파일과 디렉터리는 각 1개의 아이노드를 가지고 있고 고유한 주소를 가지고 있다.

  ![스크린샷 2020-11-11 오후 10.59.57](/Users/kimjeongdeok/TIL2/note/img/스크린샷 2020-11-11 오후 10.59.57.png)

![스크린샷 2020-11-11 오후 11.00.32](/Users/kimjeongdeok/TIL2/note/img/스크린샷 2020-11-11 오후 11.00.32.png)

### 리눅스 파일 시스템 종류

1. ext

   - minix 파일 시스템을 개선하기 위해 개발됨
   - 파일 접근에 대한 타임스탬프 기능, 아이노드 수정 기능의 부재와 조각화 이슈가 있었다.

2. ext2

   - ext의 한계를 극복하기 위해 만들어진 파일시스템.
   - 타임스탬프 기능, 아이노드 수정 기능, 조각화 이슈를 해결
   - 파일 시스템의 크기와 파일 크기도 늘어났다.

3. ext3

   - 저널링 파일 시스템이다.
   - 전원이 끊어지더라도 로그를 통해 복구할 수 있는 기능이 있다. (저널링 기술)

4. ext4

   - ext2와 ext3를 호환하며 기능을 확장했다.
   - 64비트의 기억공간 제약을 해결하여 1Exa-byte까지의 디스크 볼륨과 16Terabyte까지의 파일을 지원한다.

5. btrFS

   ![스크린샷 2020-11-11 오후 11.08.51](/Users/kimjeongdeok/TIL2/note/img/스크린샷 2020-11-11 오후 11.08.51.png)

![스크린샷 2020-11-11 오후 11.09.08](/Users/kimjeongdeok/TIL2/note/img/스크린샷 2020-11-11 오후 11.09.08.png)



### 클러스터 파일시스템

1. Raw Partitions
   - 파일시스템이 설정되어 있지 않은 상태
   - 버퍼캐시를 사용하지 않으므로 고성능의 입출력이 가능하다.
   - 파일시스템을 통하는 오버헤드가 없다
   - 숙련된 관리자의 관리가 필요하다.
2. Oracle Cluster FilesSystem(OCFS)
   - Raw Partition의 다루기 어려운 문제를 해결하면서 RAC(Real Application Cluster)의 사용 목적을 위해 설계된 파일시스템
   - Raw Partition보다 단지 2~5% 정도 속도가 느리다.



### 기타 리눅스 파일 시스템

![스크린샷 2020-11-11 오후 11.12.34](/Users/kimjeongdeok/TIL2/note/img/스크린샷 2020-11-11 오후 11.12.34.png)





















